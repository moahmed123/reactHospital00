{
  "_from": "redux-promises",
  "_id": "redux-promises@1.0.0",
  "_inBundle": false,
  "_integrity": "sha1-XdTFk74JPD8b+08T41IVcoUeWOU=",
  "_location": "/redux-promises",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "redux-promises",
    "fetchSpec": "latest",
    "name": "redux-promises",
    "raw": "redux-promises",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/redux-promises/-/redux-promises-1.0.0.tgz",
  "_shasum": "5dd4c593be093c3f1bfb4f13e3521572851e58e5",
  "_spec": "redux-promises",
  "_where": "C:\\Users\\Memosoft\\Desktop\\reactmobile",
  "author": {
    "name": "Dillon de Voor",
    "url": "http://crocodillon.com"
  },
  "bugs": {
    "url": "https://github.com/CrocoDillon/redux-promises/issues"
  },
  "bundleDependencies": false,
  "dependencies": {},
  "deprecated": false,
  "description": "Promise based middleware for Redux to deal with asynchronous actions.",
  "devDependencies": {
    "babel-cli": "^6.3.17",
    "babel-core": "^6.3.26",
    "babel-loader": "^6.2.0",
    "babel-plugin-add-module-exports": "^0.1.1",
    "babel-preset-es2015": "^6.3.13",
    "babel-register": "^6.3.13",
    "chai": "^3.4.1",
    "mocha": "^2.3.4",
    "rimraf": "^2.4.5",
    "webpack": "^1.12.9"
  },
  "files": [
    "dist",
    "lib",
    "src"
  ],
  "homepage": "https://github.com/CrocoDillon/redux-promises#readme",
  "keywords": [
    "async",
    "middleware",
    "promise",
    "redux"
  ],
  "license": "CC0-1.0",
  "main": "lib/index.js",
  "name": "redux-promises",
  "optionalDependencies": {},
  "readme": "# redux-promises\n\n[![NPM Version](https://img.shields.io/npm/v/redux-promises.svg?style=flat)](https://npmjs.org/package/redux-promises)\n[![Build Status](https://img.shields.io/travis/CrocoDillon/redux-promises.svg?style=flat)](https://travis-ci.org/CrocoDillon/redux-promises)\n\nPromise based middleware for Redux to deal with asynchronous actions. `redux-promises` is backwards compatible with [`redux-thunk`](https://github.com/gaearon/redux-thunk).\n\nIt works by collecting any promise returned by action thunks, to keep track whether or not these promises are pending or not. When there are no pending promises the state is idle.\n\n## Installation\n\n```bash\nnpm install --save redux-promises\n```\n\nYou need to use the `redux-promises` middleware and reducer.\n\n```javascript\nimport { combineReducers, applyMiddleware, createStore } from 'redux';\nimport { reducer as idleReducer, createMiddleware } from 'redux-promises';\n\nconst reducer = combineReducers({\n  idle: idleReducer,\n  // ...other reducers\n});\n\nconst promisesMiddleware = createMiddleware();\nconst store = applyMiddleware(promisesMiddleware)(createStore)(reducer);\n```\n\nYou can then call the function `ensureIdleState` which returns a promise that resolves as soon as there are no more pending promises and the state is idle.\n\n```javascript\nimport { ensureIdleState } from 'redux-promises';\n\nensureIdleState(store).then(() => {\n  // do awesome stuff knowing all promises (if any) are resolved (or rejected)\n});\n```\n\nIf you donâ€™t want to store `redux-promises` state under the `idle` key, you need to pass a function to select state to `ensureIdleState`.\n\n```javascript\nensureIdleState(store, state => state.myIdleKey).then(() => {/**/});\n```\n\n## Why?\n\nFor server-side rendering in React you need to know when all asynchronous requests are either resolved or rejected. As a bonus you get thunks for free!\n\n## Example 1\n\nA simple example, working code can be found in the `examples/simple` directory.\n\n```javascript\nimport { createStore, applyMiddleware } from 'redux';\nimport { createMiddleware, ensureIdleState } from 'redux-promises';\nimport reducers from './reducers'; // should include `redux-promises` reducer\n\nconst promisesMiddleware = createMiddleware();\nconst store = applyMiddleware(promisesMiddleware)(createStore)(reducers);\n\n// Action creator that returns a thunk that returns a promise\nconst fetchData = (url) => (dispatch) => {\n  dispatch({ type: 'FETCH_REQUEST' });\n\n  return fetch(url).then(\n    (result) => dispatch({ type: 'FETCH_SUCCESS', result }),\n    (error) => dispatch({ type: 'FETCH_FAILURE', error })\n  );\n};\n\n// Somewhere else in your application there are some dispatches\nstore.dispatch(fetchData('http://api.example.com/some/resouce'));\nstore.dispatch(fetchData('http://api.example.com/another/resouce'));\n\n// Now we wait till all required data has been fetched\nensureIdleState(store).then(() => {\n  // Fetching all data complete\n});\n```\n\n## Example 2\n\nIn the previous example if you write a lot of action creators this way you might want a helper function to create them for you. Again working code can be found in the `examples/thunk-creator` directory.\n\nCredit for this syntax (and the previous one for that matter) goes to [Dan Abramov](https://github.com/rackt/redux/issues/99#issuecomment-112212639).\n\n```javascript\nconst thunkCreator = (action) => {\n  const { types, promise, ...rest } = action;\n  const [ REQUESTED, RESOLVED, REJECTED ] = types;\n\n  return (dispatch) => {\n    dispatch({ ...rest, type: REQUESTED });\n\n    return promise.then(\n      (result) => dispatch({ ...rest, type: RESOLVED, result }),\n      (error) => dispatch({ ...rest, type: REJECTED, error })\n    );\n  };\n};\n\n// Action creator that returns a thunk that returns a promise\nconst fetchData = (url) => thunkCreator({\n  types: ['FETCH_REQUEST', 'FETCH_SUCCESS', 'FETCH_FAILURE'],\n  promise: fetch(url)\n});\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/CrocoDillon/redux-promises.git"
  },
  "scripts": {
    "build": "npm run build:lib && npm run build:umd && npm run build:umd:min",
    "build:lib": "babel src --out-dir lib",
    "build:umd": "webpack src/index.js dist/redux-promises.js",
    "build:umd:min": "NODE_ENV=production webpack src/index.js dist/redux-promises.min.js",
    "clean": "rimraf dist lib",
    "postversion": "git push && git push --tags",
    "prepublish": "npm run clean && npm run build",
    "preversion": "npm run clean && npm run test",
    "test": "mocha --compilers js:babel-register test/**",
    "version": "npm run build"
  },
  "version": "1.0.0"
}
